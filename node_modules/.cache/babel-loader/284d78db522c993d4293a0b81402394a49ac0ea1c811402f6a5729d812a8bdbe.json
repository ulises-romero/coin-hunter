{"ast":null,"code":"/**This file contains functions related to checking for, adding\r\n * and deleting .comment` files and `.comments` directories.*/\n\n/*\r\n * c\r\n * https://github.com/rumpl/c\r\n *\r\n * Copyright (c) 2012 Djordje Lukic\r\n * Licensed under the MIT license.\r\n */\n\n\"use strict\";\n\nconst fs = require(\"fs\"); //FileSystem\nconst path = require(\"path\"); //Paths\n\nconst storage = module.exports;\n\n//Constants representing the directory name & file extension, respectively.\nconst DIRECTORY = \".comments\";\nconst EXTENSION = \".comment\";\n\n/**Sets a `.comment` file for a specific file.\r\n * @param {string} absolutePathToTarget the absolute path from the\r\n * working directory to the target node.\r\n * @param {string} comment The comment to be written.\r\n * @returns {number} exit code.\r\n */\nstorage.setCommentFile = function (absolutePathToTarget, comment) {\n  //Check if `.comments` exists, makes it if not.\n  if (!storage.commentsFolderExists(path.dirname(absolutePathToTarget))) {\n    createCommentsFolder(path.dirname(absolutePathToTarget));\n  }\n  const fileObject = fs.openSync(getCommentsFile(absolutePathToTarget), \"a\", \"0644\");\n  fs.writeSync(fileObject, comment + \"\\n\", null, \"utf8\");\n  fs.closeSync(fileObject);\n  return 0;\n};\n\n/**Deletes a `.comment` file, and deletes `.comments` if it is left empty.\r\n * @param {string} absolutePathToTarget An absolute path to the\r\n * target directory.\r\n * @returns {number} exit code.\r\n */\nstorage.delete = function (absolutePathToTarget) {\n  if (!storage.commentsFolderExists(path.dirname(absolutePathToTarget))) {\n    return 1;\n  }\n  const commentsFile = getCommentsFile(absolutePathToTarget);\n\n  //If the `file.comment` does not exist...\n  if (!fs.existsSync(commentsFile)) {\n    return 1;\n  }\n  fs.unlinkSync(commentsFile);\n\n  //If the `.comments` directory is now empty...\n  if (storage.loadFiles(path.join(path.dirname(absolutePathToTarget), DIRECTORY)).length == 0) {\n    fs.rmdirSync(path.join(path.dirname(absolutePathToTarget), DIRECTORY));\n  }\n  return 0;\n};\n\n/**Checks if `.comments` exists.\r\n * @param {string} absolutePathToTargetParent the path to\r\n * the parent of the target.\r\n * @returns {boolean} true if `.comments` is present in the directory.\r\n * */\nstorage.commentsFolderExists = function (absolutePathToTargetParent) {\n  return fs.existsSync(path.join(absolutePathToTargetParent, DIRECTORY)) && fs.statSync(absolutePathToTargetParent).isDirectory();\n};\n\n/**Loads the names of all files & directories in the\r\n *  current directory, EXCEPT `.comments` folder.\r\n * @param {string} filePath a valid file path. May\r\n * be either relative or absolute.\r\n * @returns An array of filenames.\r\n */\nstorage.loadFiles = function (filePath) {\n  return fs.readdirSync(filePath).filter(file => {\n    return file !== DIRECTORY;\n  });\n};\n\n/**Loads the comments of all files & directories in the current directory.\r\n * @param {string} filePath a valid file path. May\r\n * be either relative or absolute.\r\n * @returns {array} A string array of comments.\r\n */\nstorage.loadComments = function (filePath) {\n  let comments = [];\n  const commentDir = fs.readdirSync(path.join(filePath, DIRECTORY));\n  commentDir.forEach(function (file) {\n    comments[path.basename(file, EXTENSION)] = fs.readFileSync(path.join(filePath, DIRECTORY, file)).toString();\n  });\n  return comments;\n};\n\n/**Fetches the comment associated with the current\r\ndirectory from it's parent directory.\r\n * @param {string} filePath a valid file path. May \r\n be either relative or absolute.\r\n * @returns {string} The comment associated with the directory.\r\n */\nstorage.returnCurrentDirectoryParentComment = function (filePath) {\n  const parentDir = path.join(filePath, \"../\");\n  if (!storage.commentsFolderExists(parentDir)) {\n    return \"\";\n  }\n\n  /*Loads the comments from parentDir into array; returns what is found\r\n   in the space indexed by the directory name.*/\n  const comment = storage.loadComments(parentDir)[getFileNameFromPath(filePath)];\n  if (comment) {\n    return `[Parent] ${comment}`;\n  }\n  return \"\";\n};\n\n/**Fetches the comment associated with the current\r\ndirectory from it's parent directory.\r\n * @param {string} relativePathToTarget the relative path from the \r\n * current directory to the target directory.\r\n * @returns {string} The comment associated with the directory.\r\n */\nstorage.returnCurrentDirectoryGrandparentComment = function (relativePathToTarget) {\n  const grandparentDir = path.join(relativePathToTarget, \"../../\");\n  if (!storage.commentsFolderExists(grandparentDir)) {\n    return \"\";\n  }\n\n  /*Loads the comments from grandparentDir into array; returns what is found\r\n   in the space indexed by the directory name.*/\n  const comment = storage.loadComments(grandparentDir)[getFileNameFromPath(path.join(relativePathToTarget, \"../\"))];\n  if (comment) {\n    return `[Grandparent] ${comment}`;\n  }\n  return \"\";\n};\n\n/**Finds out if the provided path is valid.\r\n * @param {string} relativePathToTarget Relative file path.\r\n * @returns {boolean} if the path exists.\r\n */\nstorage.ifPathIsValid = function (relativePathToTarget) {\n  return fs.existsSync(relativePathToTarget);\n};\n\n/**Finds out if the provided path is valid & not a file.\r\n * @param {string} relativePathToTarget Relative file path.\r\n * @returns {boolean} if the path exists & is not a file.\r\n */\nstorage.ifPathIsValidAndNotFile = function (relativePathToTarget) {\n  return fs.existsSync(relativePathToTarget) && !fs.statSync(relativePathToTarget).isFile();\n};\n\n/**Creates a `.comments` directory.\r\n * @param {string} absolutePathToParent a relative directory from the\r\n * working directory to the target files directory.\r\n * @returns {number} exit code.\r\n */\nfunction createCommentsFolder(absolutePathToParent) {\n  fs.mkdirSync(path.join(absolutePathToParent, DIRECTORY), \"0755\");\n  return 0;\n}\n\n/**Gets a single `.comment` file path from `.comments`.\r\n * @param {string} absolutePathToTarget a provided filename from the file tree.\r\n * @returns {string} parameter `file`'s equivalent `.comment` file.\r\n */\nfunction getCommentsFile(absolutePathToTarget) {\n  console.log(absolutePathToTarget);\n  const dirname = path.dirname(absolutePathToTarget);\n  const filename = getFileNameFromPath(absolutePathToTarget);\n  return path.join(dirname, DIRECTORY, filename + EXTENSION);\n}\n\n/**From a valid filepath, returns the file the path refers to.\r\n * For example, `getFileName(\"path/to/thisFile\")` returns `thisFile`.\r\n * @param {string} filePath a valid filepath, may be\r\n * either relative or absolute.\r\n * @returns {string} the filename the path refers to.\r\n */\nfunction getFileNameFromPath(filePath) {\n  return path.basename(path.resolve(filePath));\n}","map":{"version":3,"names":["fs","require","path","storage","module","exports","DIRECTORY","EXTENSION","setCommentFile","absolutePathToTarget","comment","commentsFolderExists","dirname","createCommentsFolder","fileObject","openSync","getCommentsFile","writeSync","closeSync","delete","commentsFile","existsSync","unlinkSync","loadFiles","join","length","rmdirSync","absolutePathToTargetParent","statSync","isDirectory","filePath","readdirSync","filter","file","loadComments","comments","commentDir","forEach","basename","readFileSync","toString","returnCurrentDirectoryParentComment","parentDir","getFileNameFromPath","returnCurrentDirectoryGrandparentComment","relativePathToTarget","grandparentDir","ifPathIsValid","ifPathIsValidAndNotFile","isFile","absolutePathToParent","mkdirSync","console","log","filename","resolve"],"sources":["/Users/dannyromero/Development/Web Applications/crypto-tracker/node_modules/c/src/storage.js"],"sourcesContent":["/**This file contains functions related to checking for, adding\r\n * and deleting .comment` files and `.comments` directories.*/\r\n\r\n/*\r\n * c\r\n * https://github.com/rumpl/c\r\n *\r\n * Copyright (c) 2012 Djordje Lukic\r\n * Licensed under the MIT license.\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst fs = require(\"fs\"); //FileSystem\r\nconst path = require(\"path\"); //Paths\r\n\r\nconst storage = module.exports;\r\n\r\n//Constants representing the directory name & file extension, respectively.\r\nconst DIRECTORY = \".comments\";\r\nconst EXTENSION = \".comment\";\r\n\r\n/**Sets a `.comment` file for a specific file.\r\n * @param {string} absolutePathToTarget the absolute path from the\r\n * working directory to the target node.\r\n * @param {string} comment The comment to be written.\r\n * @returns {number} exit code.\r\n */\r\nstorage.setCommentFile = function (absolutePathToTarget, comment) {\r\n  //Check if `.comments` exists, makes it if not.\r\n  if (!storage.commentsFolderExists(path.dirname(absolutePathToTarget))) {\r\n    createCommentsFolder(path.dirname(absolutePathToTarget));\r\n  }\r\n\r\n  const fileObject = fs.openSync(\r\n    getCommentsFile(absolutePathToTarget),\r\n    \"a\",\r\n    \"0644\"\r\n  );\r\n\r\n  fs.writeSync(fileObject, comment + \"\\n\", null, \"utf8\");\r\n  fs.closeSync(fileObject);\r\n\r\n  return 0;\r\n};\r\n\r\n/**Deletes a `.comment` file, and deletes `.comments` if it is left empty.\r\n * @param {string} absolutePathToTarget An absolute path to the\r\n * target directory.\r\n * @returns {number} exit code.\r\n */\r\nstorage.delete = function (absolutePathToTarget) {\r\n  if (!storage.commentsFolderExists(path.dirname(absolutePathToTarget))) {\r\n    return 1;\r\n  }\r\n\r\n  const commentsFile = getCommentsFile(absolutePathToTarget);\r\n\r\n  //If the `file.comment` does not exist...\r\n  if (!fs.existsSync(commentsFile)) {\r\n    return 1;\r\n  }\r\n\r\n  fs.unlinkSync(commentsFile);\r\n\r\n  //If the `.comments` directory is now empty...\r\n  if (\r\n    storage.loadFiles(path.join(path.dirname(absolutePathToTarget), DIRECTORY))\r\n      .length == 0\r\n  ) {\r\n    fs.rmdirSync(path.join(path.dirname(absolutePathToTarget), DIRECTORY));\r\n  }\r\n\r\n  return 0;\r\n};\r\n\r\n/**Checks if `.comments` exists.\r\n * @param {string} absolutePathToTargetParent the path to\r\n * the parent of the target.\r\n * @returns {boolean} true if `.comments` is present in the directory.\r\n * */\r\nstorage.commentsFolderExists = function (absolutePathToTargetParent) {\r\n  return (\r\n    fs.existsSync(path.join(absolutePathToTargetParent, DIRECTORY)) &&\r\n    fs.statSync(absolutePathToTargetParent).isDirectory()\r\n  );\r\n};\r\n\r\n/**Loads the names of all files & directories in the\r\n *  current directory, EXCEPT `.comments` folder.\r\n * @param {string} filePath a valid file path. May\r\n * be either relative or absolute.\r\n * @returns An array of filenames.\r\n */\r\nstorage.loadFiles = function (filePath) {\r\n  return fs.readdirSync(filePath).filter((file) => {\r\n    return file !== DIRECTORY;\r\n  });\r\n};\r\n\r\n/**Loads the comments of all files & directories in the current directory.\r\n * @param {string} filePath a valid file path. May\r\n * be either relative or absolute.\r\n * @returns {array} A string array of comments.\r\n */\r\nstorage.loadComments = function (filePath) {\r\n  let comments = [];\r\n  const commentDir = fs.readdirSync(path.join(filePath, DIRECTORY));\r\n\r\n  commentDir.forEach(function (file) {\r\n    comments[path.basename(file, EXTENSION)] = fs\r\n      .readFileSync(path.join(filePath, DIRECTORY, file))\r\n      .toString();\r\n  });\r\n\r\n  return comments;\r\n};\r\n\r\n/**Fetches the comment associated with the current\r\ndirectory from it's parent directory.\r\n * @param {string} filePath a valid file path. May \r\n be either relative or absolute.\r\n * @returns {string} The comment associated with the directory.\r\n */\r\nstorage.returnCurrentDirectoryParentComment = function (filePath) {\r\n  const parentDir = path.join(filePath, \"../\");\r\n\r\n  if (!storage.commentsFolderExists(parentDir)) {\r\n    return \"\";\r\n  }\r\n\r\n  /*Loads the comments from parentDir into array; returns what is found\r\n   in the space indexed by the directory name.*/\r\n  const comment = storage.loadComments(parentDir)[\r\n    getFileNameFromPath(filePath)\r\n  ];\r\n\r\n  if (comment) {\r\n    return `[Parent] ${comment}`;\r\n  }\r\n\r\n  return \"\";\r\n};\r\n\r\n/**Fetches the comment associated with the current\r\ndirectory from it's parent directory.\r\n * @param {string} relativePathToTarget the relative path from the \r\n * current directory to the target directory.\r\n * @returns {string} The comment associated with the directory.\r\n */\r\nstorage.returnCurrentDirectoryGrandparentComment = function (\r\n  relativePathToTarget\r\n) {\r\n  const grandparentDir = path.join(relativePathToTarget, \"../../\");\r\n\r\n  if (!storage.commentsFolderExists(grandparentDir)) {\r\n    return \"\";\r\n  }\r\n\r\n  /*Loads the comments from grandparentDir into array; returns what is found\r\n   in the space indexed by the directory name.*/\r\n  const comment = storage.loadComments(grandparentDir)[\r\n    getFileNameFromPath(path.join(relativePathToTarget, \"../\"))\r\n  ];\r\n\r\n  if (comment) {\r\n    return `[Grandparent] ${comment}`;\r\n  }\r\n\r\n  return \"\";\r\n};\r\n\r\n/**Finds out if the provided path is valid.\r\n * @param {string} relativePathToTarget Relative file path.\r\n * @returns {boolean} if the path exists.\r\n */\r\nstorage.ifPathIsValid = function (relativePathToTarget) {\r\n  return fs.existsSync(relativePathToTarget);\r\n};\r\n\r\n/**Finds out if the provided path is valid & not a file.\r\n * @param {string} relativePathToTarget Relative file path.\r\n * @returns {boolean} if the path exists & is not a file.\r\n */\r\nstorage.ifPathIsValidAndNotFile = function (relativePathToTarget) {\r\n  return (\r\n    fs.existsSync(relativePathToTarget) &&\r\n    !fs.statSync(relativePathToTarget).isFile()\r\n  );\r\n};\r\n\r\n/**Creates a `.comments` directory.\r\n * @param {string} absolutePathToParent a relative directory from the\r\n * working directory to the target files directory.\r\n * @returns {number} exit code.\r\n */\r\nfunction createCommentsFolder(absolutePathToParent) {\r\n  fs.mkdirSync(path.join(absolutePathToParent, DIRECTORY), \"0755\");\r\n  return 0;\r\n}\r\n\r\n/**Gets a single `.comment` file path from `.comments`.\r\n * @param {string} absolutePathToTarget a provided filename from the file tree.\r\n * @returns {string} parameter `file`'s equivalent `.comment` file.\r\n */\r\nfunction getCommentsFile(absolutePathToTarget) {\r\n  console.log(absolutePathToTarget);\r\n  const dirname = path.dirname(absolutePathToTarget);\r\n  const filename = getFileNameFromPath(absolutePathToTarget);\r\n\r\n  return path.join(dirname, DIRECTORY, filename + EXTENSION);\r\n}\r\n\r\n/**From a valid filepath, returns the file the path refers to.\r\n * For example, `getFileName(\"path/to/thisFile\")` returns `thisFile`.\r\n * @param {string} filePath a valid filepath, may be\r\n * either relative or absolute.\r\n * @returns {string} the filename the path refers to.\r\n */\r\nfunction getFileNameFromPath(filePath) {\r\n  return path.basename(path.resolve(filePath));\r\n}\r\n"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;AAC1B,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;;AAE9B,MAAME,OAAO,GAAGC,MAAM,CAACC,OAAO;;AAE9B;AACA,MAAMC,SAAS,GAAG,WAAW;AAC7B,MAAMC,SAAS,GAAG,UAAU;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACAJ,OAAO,CAACK,cAAc,GAAG,UAAUC,oBAAoB,EAAEC,OAAO,EAAE;EAChE;EACA,IAAI,CAACP,OAAO,CAACQ,oBAAoB,CAACT,IAAI,CAACU,OAAO,CAACH,oBAAoB,CAAC,CAAC,EAAE;IACrEI,oBAAoB,CAACX,IAAI,CAACU,OAAO,CAACH,oBAAoB,CAAC,CAAC;EAC1D;EAEA,MAAMK,UAAU,GAAGd,EAAE,CAACe,QAAQ,CAC5BC,eAAe,CAACP,oBAAoB,CAAC,EACrC,GAAG,EACH,MAAM,CACP;EAEDT,EAAE,CAACiB,SAAS,CAACH,UAAU,EAAEJ,OAAO,GAAG,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC;EACtDV,EAAE,CAACkB,SAAS,CAACJ,UAAU,CAAC;EAExB,OAAO,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAX,OAAO,CAACgB,MAAM,GAAG,UAAUV,oBAAoB,EAAE;EAC/C,IAAI,CAACN,OAAO,CAACQ,oBAAoB,CAACT,IAAI,CAACU,OAAO,CAACH,oBAAoB,CAAC,CAAC,EAAE;IACrE,OAAO,CAAC;EACV;EAEA,MAAMW,YAAY,GAAGJ,eAAe,CAACP,oBAAoB,CAAC;;EAE1D;EACA,IAAI,CAACT,EAAE,CAACqB,UAAU,CAACD,YAAY,CAAC,EAAE;IAChC,OAAO,CAAC;EACV;EAEApB,EAAE,CAACsB,UAAU,CAACF,YAAY,CAAC;;EAE3B;EACA,IACEjB,OAAO,CAACoB,SAAS,CAACrB,IAAI,CAACsB,IAAI,CAACtB,IAAI,CAACU,OAAO,CAACH,oBAAoB,CAAC,EAAEH,SAAS,CAAC,CAAC,CACxEmB,MAAM,IAAI,CAAC,EACd;IACAzB,EAAE,CAAC0B,SAAS,CAACxB,IAAI,CAACsB,IAAI,CAACtB,IAAI,CAACU,OAAO,CAACH,oBAAoB,CAAC,EAAEH,SAAS,CAAC,CAAC;EACxE;EAEA,OAAO,CAAC;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAH,OAAO,CAACQ,oBAAoB,GAAG,UAAUgB,0BAA0B,EAAE;EACnE,OACE3B,EAAE,CAACqB,UAAU,CAACnB,IAAI,CAACsB,IAAI,CAACG,0BAA0B,EAAErB,SAAS,CAAC,CAAC,IAC/DN,EAAE,CAAC4B,QAAQ,CAACD,0BAA0B,CAAC,CAACE,WAAW,EAAE;AAEzD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA1B,OAAO,CAACoB,SAAS,GAAG,UAAUO,QAAQ,EAAE;EACtC,OAAO9B,EAAE,CAAC+B,WAAW,CAACD,QAAQ,CAAC,CAACE,MAAM,CAAEC,IAAI,IAAK;IAC/C,OAAOA,IAAI,KAAK3B,SAAS;EAC3B,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAH,OAAO,CAAC+B,YAAY,GAAG,UAAUJ,QAAQ,EAAE;EACzC,IAAIK,QAAQ,GAAG,EAAE;EACjB,MAAMC,UAAU,GAAGpC,EAAE,CAAC+B,WAAW,CAAC7B,IAAI,CAACsB,IAAI,CAACM,QAAQ,EAAExB,SAAS,CAAC,CAAC;EAEjE8B,UAAU,CAACC,OAAO,CAAC,UAAUJ,IAAI,EAAE;IACjCE,QAAQ,CAACjC,IAAI,CAACoC,QAAQ,CAACL,IAAI,EAAE1B,SAAS,CAAC,CAAC,GAAGP,EAAE,CAC1CuC,YAAY,CAACrC,IAAI,CAACsB,IAAI,CAACM,QAAQ,EAAExB,SAAS,EAAE2B,IAAI,CAAC,CAAC,CAClDO,QAAQ,EAAE;EACf,CAAC,CAAC;EAEF,OAAOL,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAhC,OAAO,CAACsC,mCAAmC,GAAG,UAAUX,QAAQ,EAAE;EAChE,MAAMY,SAAS,GAAGxC,IAAI,CAACsB,IAAI,CAACM,QAAQ,EAAE,KAAK,CAAC;EAE5C,IAAI,CAAC3B,OAAO,CAACQ,oBAAoB,CAAC+B,SAAS,CAAC,EAAE;IAC5C,OAAO,EAAE;EACX;;EAEA;AACF;EACE,MAAMhC,OAAO,GAAGP,OAAO,CAAC+B,YAAY,CAACQ,SAAS,CAAC,CAC7CC,mBAAmB,CAACb,QAAQ,CAAC,CAC9B;EAED,IAAIpB,OAAO,EAAE;IACX,OAAQ,YAAWA,OAAQ,EAAC;EAC9B;EAEA,OAAO,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAP,OAAO,CAACyC,wCAAwC,GAAG,UACjDC,oBAAoB,EACpB;EACA,MAAMC,cAAc,GAAG5C,IAAI,CAACsB,IAAI,CAACqB,oBAAoB,EAAE,QAAQ,CAAC;EAEhE,IAAI,CAAC1C,OAAO,CAACQ,oBAAoB,CAACmC,cAAc,CAAC,EAAE;IACjD,OAAO,EAAE;EACX;;EAEA;AACF;EACE,MAAMpC,OAAO,GAAGP,OAAO,CAAC+B,YAAY,CAACY,cAAc,CAAC,CAClDH,mBAAmB,CAACzC,IAAI,CAACsB,IAAI,CAACqB,oBAAoB,EAAE,KAAK,CAAC,CAAC,CAC5D;EAED,IAAInC,OAAO,EAAE;IACX,OAAQ,iBAAgBA,OAAQ,EAAC;EACnC;EAEA,OAAO,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA;AACAP,OAAO,CAAC4C,aAAa,GAAG,UAAUF,oBAAoB,EAAE;EACtD,OAAO7C,EAAE,CAACqB,UAAU,CAACwB,oBAAoB,CAAC;AAC5C,CAAC;;AAED;AACA;AACA;AACA;AACA1C,OAAO,CAAC6C,uBAAuB,GAAG,UAAUH,oBAAoB,EAAE;EAChE,OACE7C,EAAE,CAACqB,UAAU,CAACwB,oBAAoB,CAAC,IACnC,CAAC7C,EAAE,CAAC4B,QAAQ,CAACiB,oBAAoB,CAAC,CAACI,MAAM,EAAE;AAE/C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,SAASpC,oBAAoB,CAACqC,oBAAoB,EAAE;EAClDlD,EAAE,CAACmD,SAAS,CAACjD,IAAI,CAACsB,IAAI,CAAC0B,oBAAoB,EAAE5C,SAAS,CAAC,EAAE,MAAM,CAAC;EAChE,OAAO,CAAC;AACV;;AAEA;AACA;AACA;AACA;AACA,SAASU,eAAe,CAACP,oBAAoB,EAAE;EAC7C2C,OAAO,CAACC,GAAG,CAAC5C,oBAAoB,CAAC;EACjC,MAAMG,OAAO,GAAGV,IAAI,CAACU,OAAO,CAACH,oBAAoB,CAAC;EAClD,MAAM6C,QAAQ,GAAGX,mBAAmB,CAAClC,oBAAoB,CAAC;EAE1D,OAAOP,IAAI,CAACsB,IAAI,CAACZ,OAAO,EAAEN,SAAS,EAAEgD,QAAQ,GAAG/C,SAAS,CAAC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoC,mBAAmB,CAACb,QAAQ,EAAE;EACrC,OAAO5B,IAAI,CAACoC,QAAQ,CAACpC,IAAI,CAACqD,OAAO,CAACzB,QAAQ,CAAC,CAAC;AAC9C"},"metadata":{},"sourceType":"script","externalDependencies":[]}