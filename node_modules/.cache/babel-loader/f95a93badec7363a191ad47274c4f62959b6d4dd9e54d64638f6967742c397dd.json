{"ast":null,"code":"//!Defines two helper functions.\n\n/*\r\n * c\r\n * https://github.com/rumpl/c\r\n *\r\n * Copyright (c) 2012 Djordje Lukic\r\n * Licensed under the MIT license.\r\n */\n\n\"use strict\";\n\nconst helpers = module.exports;\nconst colors = require(\"colors/safe\"); //Despite looking unused, is not unused.\nconst fs = require(\"fs\");\nconst SPACING = 1; //Change this value if you want more or less space between file names and comments.\nconst PADDING = \" \"; //Change this value for what character should present your padding.\n\n/**Prints a coloured node name, padding, and it's assigned comment.\r\n * @param {string} nodeName The name of the node.\r\n * @param {string} nodeComment The comment for the node.\r\n * @param {number} maxLine The length of the longest node name in the specified directory.\r\n * @param {string} dir the relative filepath to a directory, the contents of which will be listed.\r\n */\nfunction print(nodeName, nodeComment, maxLine, dir) {\n  nodeComment = nodeComment || \"\";\n  nodeComment = nodeComment.replace(/(\\r\\n|\\n|\\r)/gm, \" \"); //Removes any new lines with blank spaces.\n  let pad;\n\n  //The amount of spacing & the colouring changes depending on whether 'file' is a file or a directory.\n  if (fs.statSync(dir + \"/\" + nodeName).isFile()) {\n    pad = PADDING.repeat(maxLine - nodeName.length + 1 + SPACING);\n    console.log(\n    // @ts-ignore - TS compiler throws an unnecessary error.\n    colors.brightGreen(nodeName) + pad + colors.yellow(nodeComment));\n  } else {\n    pad = PADDING.repeat(maxLine - nodeName.length + SPACING);\n    console.log(\n    // @ts-ignore - TS compiler throws an unnecessary error.\n    colors.brightCyan(nodeName + \"/\") + pad + colors.yellow(nodeComment));\n  }\n}\n\n//TODO: refactor printFileComments & printOnlyComments into one function - they're almost identical for the most part\n\n/**Prints all of the files and sub-directories of a specified directory, as well as their assigned comments.\r\n * @param {Array<string>} files An array of all of the file names in the specified directory.\r\n * @param {Array<string>} comments An array of all of the comments in the specified directory.\r\n * @param {string} dir the relative filepath to a directory, the content of which will be listed.\r\n */\nhelpers.printFileComments = function (files, comments, dir) {\n  //Gets the length of the longest filename in the array - iterators through files.\n  const maxLine = maxLength(files);\n\n  //Prints the current file and it's comment\n  print(\".\", comments[\".\"], maxLine, dir);\n  print(\"..\", comments[\"..\"], maxLine, dir);\n\n  //For each file run the print function.\n  files.forEach(function (file) {\n    print(file, comments[file], maxLine, dir);\n  });\n};\n\n/**Prints only the files and sub-directories of a specified directory which have comments, as well as their assigned comments.\r\n * @param {Array<string>} filesNames An array of all of the file names in the specified directory.\r\n * @param {Array<string>} comments An array of all of the comments in the specified directory.\r\n * @param {string} relativePathToTarget the relative filepath to a directory, the content of which will be listed.\r\n */\nhelpers.printOnlyComments = function (filesNames, comments, relativePathToTarget) {\n  //Gets the length of the longest filename in the array - iterators through files.\n  const maxLine = maxLength(filesNames);\n\n  //Prints the current file and it's comment\n  if (comments[\".\"]) print(\".\", comments[\".\"], maxLine, relativePathToTarget);\n  if (comments[\"..\"]) print(\"..\", comments[\"..\"], maxLine, relativePathToTarget);\n\n  //For each file with a comment, run the print function.\n  filesNames.forEach(function (file) {\n    if (comments[file]) print(file, comments[file], maxLine, relativePathToTarget);\n  });\n};\n\n/**Calculates the longest file name from all the returned files.\r\n * @param {Array<string>} files an array of all the file names in the specified directory.\r\n * @returns {number} Returns the length of the longest name in the array.\r\n */\nfunction maxLength(files) {\n  return files.reduce((a, b) => {\n    return b.length > a ? b.length : a;\n  }, 0);\n}","map":{"version":3,"names":["helpers","module","exports","colors","require","fs","SPACING","PADDING","print","nodeName","nodeComment","maxLine","dir","replace","pad","statSync","isFile","repeat","length","console","log","brightGreen","yellow","brightCyan","printFileComments","files","comments","maxLength","forEach","file","printOnlyComments","filesNames","relativePathToTarget","reduce","a","b"],"sources":["/Users/dannyromero/Development/Web Applications/crypto-tracker/node_modules/c/src/helpers.js"],"sourcesContent":["//!Defines two helper functions.\r\n\r\n/*\r\n * c\r\n * https://github.com/rumpl/c\r\n *\r\n * Copyright (c) 2012 Djordje Lukic\r\n * Licensed under the MIT license.\r\n */\r\n\r\n\"use strict\";\r\nconst helpers = module.exports;\r\nconst colors = require(\"colors/safe\"); //Despite looking unused, is not unused.\r\nconst fs = require(\"fs\");\r\n\r\nconst SPACING = 1; //Change this value if you want more or less space between file names and comments.\r\nconst PADDING = \" \"; //Change this value for what character should present your padding.\r\n\r\n/**Prints a coloured node name, padding, and it's assigned comment.\r\n * @param {string} nodeName The name of the node.\r\n * @param {string} nodeComment The comment for the node.\r\n * @param {number} maxLine The length of the longest node name in the specified directory.\r\n * @param {string} dir the relative filepath to a directory, the contents of which will be listed.\r\n */\r\nfunction print(nodeName, nodeComment, maxLine, dir) {\r\n  nodeComment = nodeComment || \"\";\r\n  nodeComment = nodeComment.replace(/(\\r\\n|\\n|\\r)/gm, \" \"); //Removes any new lines with blank spaces.\r\n  let pad;\r\n\r\n  //The amount of spacing & the colouring changes depending on whether 'file' is a file or a directory.\r\n  if (fs.statSync(dir + \"/\" + nodeName).isFile()) {\r\n    pad = PADDING.repeat(maxLine - nodeName.length + 1 + SPACING);\r\n    console.log(\r\n      // @ts-ignore - TS compiler throws an unnecessary error.\r\n      colors.brightGreen(nodeName) + pad + colors.yellow(nodeComment)\r\n    );\r\n  } else {\r\n    pad = PADDING.repeat(maxLine - nodeName.length + SPACING);\r\n    console.log(\r\n      // @ts-ignore - TS compiler throws an unnecessary error.\r\n      colors.brightCyan(nodeName + \"/\") + pad + colors.yellow(nodeComment)\r\n    );\r\n  }\r\n}\r\n\r\n//TODO: refactor printFileComments & printOnlyComments into one function - they're almost identical for the most part\r\n\r\n/**Prints all of the files and sub-directories of a specified directory, as well as their assigned comments.\r\n * @param {Array<string>} files An array of all of the file names in the specified directory.\r\n * @param {Array<string>} comments An array of all of the comments in the specified directory.\r\n * @param {string} dir the relative filepath to a directory, the content of which will be listed.\r\n */\r\nhelpers.printFileComments = function (files, comments, dir) {\r\n  //Gets the length of the longest filename in the array - iterators through files.\r\n  const maxLine = maxLength(files);\r\n\r\n  //Prints the current file and it's comment\r\n  print(\".\", comments[\".\"], maxLine, dir);\r\n  print(\"..\", comments[\"..\"], maxLine, dir);\r\n\r\n  //For each file run the print function.\r\n  files.forEach(function (file) {\r\n    print(file, comments[file], maxLine, dir);\r\n  });\r\n};\r\n\r\n/**Prints only the files and sub-directories of a specified directory which have comments, as well as their assigned comments.\r\n * @param {Array<string>} filesNames An array of all of the file names in the specified directory.\r\n * @param {Array<string>} comments An array of all of the comments in the specified directory.\r\n * @param {string} relativePathToTarget the relative filepath to a directory, the content of which will be listed.\r\n */\r\nhelpers.printOnlyComments = function (\r\n  filesNames,\r\n  comments,\r\n  relativePathToTarget\r\n) {\r\n  //Gets the length of the longest filename in the array - iterators through files.\r\n  const maxLine = maxLength(filesNames);\r\n\r\n  //Prints the current file and it's comment\r\n  if (comments[\".\"]) print(\".\", comments[\".\"], maxLine, relativePathToTarget);\r\n  if (comments[\"..\"])\r\n    print(\"..\", comments[\"..\"], maxLine, relativePathToTarget);\r\n\r\n  //For each file with a comment, run the print function.\r\n  filesNames.forEach(function (file) {\r\n    if (comments[file])\r\n      print(file, comments[file], maxLine, relativePathToTarget);\r\n  });\r\n};\r\n\r\n/**Calculates the longest file name from all the returned files.\r\n * @param {Array<string>} files an array of all the file names in the specified directory.\r\n * @returns {number} Returns the length of the longest name in the array.\r\n */\r\nfunction maxLength(files) {\r\n  return files.reduce((a, b) => {\r\n    return b.length > a ? b.length : a;\r\n  }, 0);\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}